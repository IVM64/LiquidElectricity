//Programmer: Irak Mayer
//Original Date: 11/02/2022
//License: MIT.

#include <Notecard.h>
#include <Adafruit_INA219.h>
#include "Adafruit_LC709203F.h"
#include <Adafruit_SSD1327.h>

#define OLED_RESET -1

Adafruit_SSD1327 display(128, 128, &Wire, OLED_RESET, 1000000);

Adafruit_LC709203F lc;
Adafruit_INA219 ina219;

//NoteCard product id. Please add your product id below.
#define myProductID "yourProductIdHere"
//Create Notecard object instance.
Notecard notecard;

byte sensorPin       = 14; //ESP32 14;  STM32 5;

// The hall-effect flow sensor outputs approximately 4.5 pulses per second per
// litre/minute of flow.
float calibrationFactor = 4.5;

//Global variables to keep count of the sensor flow.
volatile long pulseCount;  
unsigned long pulseCountPerDelay;
long pulseCountperSec;
float flowRate;
unsigned int flowMilliLitres;
unsigned long totalMilliLitres;

//Gloabl timers to keep track of sensor data sampling.
unsigned long oldTime;
unsigned long startTime;
unsigned long delayBetweenSamples = 10000;
unsigned long startTimeMQTT;
unsigned long delayBetweenSamplesMQTT = 60000;

//Memory buffers to format sensor data.
char buf[200];
char bufTemp[200];
char batteryStatus[1024];
char inPowerStatus[1024];
char flowRateStatus[512];

//Initialize LC709203F sensor, which monitors the battery percentage and voltage.
bool initBatteryReader(){
  if (!lc.begin()) {
    Serial.println(F("Couldnt find Adafruit LC709203F?\nMake sure a battery is plugged in!"));
    return false;
  }
  Serial.println(F("Found LC709203F"));
  Serial.print("Version: 0x"); Serial.println(lc.getICversion(), HEX);

  lc.setThermistorB(3950);
  Serial.print("Thermistor B = "); Serial.println(lc.getThermistorB());

  lc.setPackSize(LC709203F_APA_500MAH);
  lc.setAlarmVoltage(3.8);

  return true;
}

//This function initilize the INA219 device to monitor the amount of current and voltage an external power source produces.
bool initPowerMetricDevice(){
    uint32_t currentFrequency;
    
  // Initialize the INA219.
  if (! ina219.begin()) {
    Serial.println("Failed to find INA219 chip");
    return false;
  }
  // Use a lower 16V, 400mA range (higher precision on volts and amps):
  ina219.setCalibration_16V_400mA();
  Serial.println("Measuring voltage and current with INA219 ...");

  return true;
}

//Initialize the Blues Wireless Notecard.
void initNoteCard()
{
    Wire.begin();
    notecard.begin(0x17,30,Wire);  
    
    J *req = notecard.newRequest("hub.set");
    JAddStringToObject(req, "product", myProductID);
    JAddStringToObject(req, "mode", "continuous");
    notecard.sendRequest(req);
}

//Reads the power generated by the external source.
//Return a formatted string with the sensor data
//Return a JSON object with the sensor data
void readPower(char *dataStr, J *obj){
  float shuntvoltage = 0;
  float busvoltage = 0;
  float loadvoltage = 0;
  float current = 0;

  shuntvoltage = ina219.getShuntVoltage_mV();
  busvoltage = ina219.getBusVoltage_V();
  loadvoltage = busvoltage + (shuntvoltage / 1000);
  current = ina219.getCurrent_mA();

  sprintf(dataStr,"%.2f",current);
  
  JAddNumberToObject(obj, "Bus", busvoltage);
  JAddNumberToObject(obj, "Shunt", shuntvoltage);
  JAddNumberToObject(obj, "Load", loadvoltage);
  JAddNumberToObject(obj, "Current", current);
  JAddNumberToObject(obj, "Power", ina219.getPower_mW());                    
}

//Reads the battery status percentage, voltage and temperature
//Return a formatted string with the sensor data
//Return a JSON object with the sensor data
void readBattery(char *dataStr, char *temp, J *obj){

  sprintf(dataStr,"%.2f",lc.cellPercent());
  sprintf(temp,"%.1f",lc.getCellTemperature());

  JAddNumberToObject(obj, "Voltage", lc.cellVoltage());
  JAddNumberToObject(obj, "Percent", lc.cellPercent());
  JAddNumberToObject(obj, "Temp", lc.getCellTemperature());
}

/*
Insterrupt Service Routine
 */
//void ICACHE_RAM_ATTR pulseCounter() //AVR arduino
//void pulseCounter() //STM32 board
void IRAM_ATTR pulseCounter() //ESP32 
{
  // Increment the pulse counter
  pulseCount++;
}

//Initialize the OLED display
void initOLED(){
    if ( ! display.begin(0x3D) ) {
     Serial.println("Unable to initialize OLED");
     while (1) yield();
  }
  display.clearDisplay();
  display.display();
}

//Display main dashboard interface
void drawtext(int posX, int posY, int fontsize, char *text, uint16_t color) {
  display.setCursor(posX, posY);
  display.setTextColor(color);
  display.setTextSize(fontsize);
  display.setTextWrap(true);
  display.println(text);
}

//Initialialize dashboard elements.
void initDashboard(){
  display.setRotation(3);
  display.fillScreen(SSD1327_BLACK);

  // large block of text
  display.fillScreen(SSD1327_BLACK);
  drawtext(0,0,1,"Battery : 100.0 %",SSD1327_WHITE);
  drawtext(0,35,1,"Current: 24.2334",SSD1327_WHITE);
  drawtext(0,65,1,"Flow : 23.4334",SSD1327_WHITE);
  drawtext(0,95,1,"Temp : 76.988 C",SSD1327_WHITE);
  display.display();
}

//Reset the display area specified by the parameters. Remember to call display.display() to refresh the display
void resetArea(int x, int y, int width, int height){
  display.fillRect(x, y, width, height, SSD1327_BLACK);
}

//Reset the current dashboard text
void resetText(){
  resetArea(60,0,50,12);
  resetArea(52,35,50,12);
  resetArea(40,60,50,12);
  resetArea(40,95,50,12);
}

//Refresh the dashboard text with the values passed on the parameters
void refreshText(char *battery, char *power, char *flow, char *temp){
  resetText();
  drawtext(60,0,1,battery,SSD1327_WHITE);
  drawtext(60,35,1,power,SSD1327_WHITE);
  drawtext(40,65,1,flow,SSD1327_WHITE);
  drawtext(40,95,1,temp,SSD1327_WHITE);
  display.display();
}

//Initiaize all the peripherals.
void setup(){
    Serial.begin(9600);
  // put your setup code here, to run once:
  initNoteCard();
  //start sampling timers.
  startTime = millis();
  startTimeMQTT = millis();
  
  pinMode(sensorPin, INPUT);
  digitalWrite(sensorPin, HIGH);

  pulseCount        = 0;
  pulseCountPerDelay= 0;
  flowRate          = 0.0;
  flowMilliLitres   = 0;
  totalMilliLitres  = 0;
  oldTime           = 0;

  attachInterrupt(digitalPinToInterrupt(sensorPin), pulseCounter, RISING); 

  initBatteryReader();
  initPowerMetricDevice();
  initOLED();
  initDashboard();

  resetText();
  display.display();
}

//Main loop
//data sampling and communication to the cloud service.
void loop() {

   if((millis() - oldTime) > 1000)    // Only process counters once per second
   { 
      // Disable the interrupt while calculating flow rate and sending the value to
      // the host        
      detachInterrupt(digitalPinToInterrupt(sensorPin));
  
      flowRate = ((1000.0 / (millis() - oldTime)) * pulseCount) / calibrationFactor;
      oldTime = millis();
      flowMilliLitres = (flowRate / 60) * 1000;
      totalMilliLitres += flowMilliLitres;
  
      pulseCountperSec = pulseCount;
      pulseCountPerDelay += pulseCountperSec;
      pulseCount = 0;
      
      // Enable the interrupt again now that we've finished sending output
      attachInterrupt(digitalPinToInterrupt(sensorPin), pulseCounter, RISING); 
   }

   //Is the sampling time passed?
   if ((millis() - startTime > delayBetweenSamples)){ 
     startTime = millis();
      J *req = notecard.newRequest("note.add");
      if (req != NULL) {
          JAddBoolToObject(req, "sync", true);
          J *body = JCreateObject();
          if (body != NULL) {
              //Flow sensor data
              J *flow = JCreateObject();
              JAddNumberToObject(flow, "waterflowperrev", pulseCountperSec);
              JAddNumberToObject(flow, "waterflowperlt", flowMilliLitres);
              JAddItemToObject(body, "flow", flow);
              //Battery monitor data
              J *battery = JCreateObject();
              readBattery(batteryStatus, bufTemp, battery);
              JAddItemToObject(body, "battery", battery);
              //Water turbine power data
              J *power = JCreateObject();
              readPower(inPowerStatus, power);
              JAddItemToObject(body, "power", power);
              JAddItemToObject(req, "body", body);
              sprintf(buf,"%d",pulseCountperSec);
              refreshText(batteryStatus, inPowerStatus, buf, bufTemp);
          }
          //Send normal sampling to Blues Wireless NoteHub
          notecard.sendRequest(req);
          //Is the MQTT sampling timer trigger?
          if ((millis() - startTimeMQTT > delayBetweenSamplesMQTT)){
            startTimeMQTT = millis();
            J *reqMQTT = notecard.newRequest("note.add");
            JAddStringToObject(reqMQTT, "file", "sensors.qo");
            JAddBoolToObject(reqMQTT, "sync", true);
            if (req != NULL) {
              JAddBoolToObject(reqMQTT, "sync", true);
              J *bodyMQTT = JCreateObject();
              if (bodyMQTT != NULL) {
                  //Water flow sensor data to MQTT 
                  J *flowMQTT = JCreateObject();
                  JAddNumberToObject(flowMQTT, "waterflowperrev", pulseCountperSec);
                  JAddNumberToObject(flowMQTT, "waterflowperlt", flowMilliLitres);
                  JAddItemToObject(bodyMQTT, "flow", flowMQTT);
                  //Battery monitor data to MQTT
                  J *batteryMQTT = JCreateObject();
                  readBattery(batteryStatus, bufTemp, batteryMQTT);
                  JAddItemToObject(bodyMQTT, "battery", batteryMQTT);
                  //Water turbine power data
                  J *powerMQTT = JCreateObject();
                  readPower(inPowerStatus, powerMQTT);
                  JAddItemToObject(bodyMQTT, "power", powerMQTT);
                  JAddItemToObject(reqMQTT, "body", bodyMQTT);
              }
              //Send data to Adafruit MQTT thru a Blues Wireless router
              notecard.sendRequest(reqMQTT);
            }
          }
          pulseCountPerDelay = pulseCountperSec = 0;
      }      
      else{
        Serial.print("req failed");
      }
   }
}
